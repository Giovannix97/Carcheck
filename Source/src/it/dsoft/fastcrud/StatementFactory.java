package it.dsoft.fastcrud;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Iterator;
import java.util.LinkedHashMap;

import it.dsoft.fastcrud.core.BeanManager;
import it.dsoft.fastcrud.core.interfaces.IBeanEntity;
import it.dsoft.fastcrud.enums.StatementType;
import it.dsoft.fastcrud.exceptions.ObjectMapException;
import it.dsoft.fastcrud.exceptions.TableNameException;

/**
 * This class deals with the creation of various prepared statements
 * @author Daniele De Falco
 *
 */
class StatementFactory {

	/**
	 * 
	 */
	public StatementFactory() {
		this.beanManager = new BeanManager();
	}
	
	/**
	 * Method that allows the creation of various prepared statements
	 * @param statementType Type of statement to generate
	 * @param connection Sql Connection
	 * @param beanEntity Entity on which to generate the statement
	 * @param sql Sql string
	 * @return New prepared statement
	 * @throws SQLException Exception generated by the Java.sql library
	 * @throws Exception Generic exception
	 */
	public <T> PreparedStatement createStatement(StatementType statementType, Connection connection, IBeanEntity<T> beanEntity, String sql, Object...args) throws SQLException, Exception {
		if(connection.isClosed())
			throw new SQLException("connection is closed");
		
		if(beanEntity == null)
			throw new NullPointerException("beanEntity is null");
		
		if(statementType == StatementType.Create)
			return getCreateStatement(connection, beanEntity, sql);
		else if(statementType == StatementType.Update)
			return getUpdateStatement(connection, beanEntity, sql);
		else if(statementType == StatementType.Delete)
			return getDeleteStatement(connection, beanEntity, sql);
		else if(statementType == StatementType.Read)
			return getReadStatement(connection, sql, args);
		
		return null;
	}
	
	/**
	 * Method that allows the creation of various prepared statements
	 * @param connection Sql Connection
	 * @param beanEntity Entity on which to generate the statement
	 * @param sql Sql string
	 * @return New prepared statement
	 * @throws SQLException Exception generated by the Java.sql library
	 * @throws ObjectMapException Exception generated when an object can not be mapped
	 * @throws TableNameException Exception generated when the name of a table is not found
	 */
	private <T> PreparedStatement getCreateStatement(Connection connection, IBeanEntity<T> beanEntity, String sql) throws SQLException, ObjectMapException, TableNameException {
		PreparedStatement statement = connection.prepareStatement(sql, new String[] {beanEntity.getPrimaryKey().GetKey()});
		LinkedHashMap<String, String> map = this.beanManager.MapObject(beanEntity);
		
		Iterator<String> keys = map.keySet().iterator();
		for(int i = 0; keys.hasNext(); i++) {
			String value = map.get(keys.next());
			statement.setObject(i + 1, value);
		}
		
		return statement;
	}
	
	/**
	 * Method that allows the creation of various prepared statements
	 * @param connection Sql Connection
	 * @param beanEntity Entity on which to generate the statement
	 * @param sql Sql string
	 * @return New prepared statement
	 * @throws SQLException Exception generated by the Java.sql library
	 * @throws ObjectMapException Exception generated when an object can not be mapped
	 * @throws TableNameException Exception generated when the name of a table is not found
	 */
	private <T> PreparedStatement getUpdateStatement(Connection connection, IBeanEntity<T> beanEntity, String sql) throws SQLException, ObjectMapException, TableNameException {
		PreparedStatement statement = connection.prepareStatement(sql, new String[] {beanEntity.getPrimaryKey().GetKey()});
		LinkedHashMap<String, String> map = this.beanManager.MapObject(beanEntity);
		
		Iterator<String> keys = map.keySet().iterator();
		for(int i = 0; keys.hasNext(); i++) {
			String value = map.get(keys.next());
			statement.setObject(i + 1, value);
		}
		
		statement.setObject(map.size() + 1, beanEntity.getPrimaryKey().GetValue());
		return statement;
	}
	
	/**
	 * Method that allows the creation of various prepared statements
	 * @param connection Sql Connection
	 * @param beanEntity Entity on which to generate the statement
	 * @param sql Sql string
	 * @return New prepared statement
	 * @throws SQLException Exception generated by the Java.sql library
	 */
	private <T> PreparedStatement getDeleteStatement(Connection connection, IBeanEntity<T> beanEntity, String sql) throws SQLException {
		PreparedStatement statement = connection.prepareStatement(sql, new String[] {beanEntity.getPrimaryKey().GetKey()});
		String primaryKey = beanEntity.getPrimaryKey().GetValue();
		
		statement.setObject(1, primaryKey);
		return statement;
	}
	
	/**
	 * Method that allows the creation of various prepared statements
	 * @param connection Sql Connection
	 * @param sql Sql string
	 * @return New prepared statement
	 * @throws SQLException Exception generated by the Java.sql library
	 */
	private <T> PreparedStatement getReadStatement(Connection connection, String sql, Object...args) throws SQLException {
		PreparedStatement preparedStatement = connection.prepareStatement(sql);
		for(int i = 0; i < args.length; i++)
			preparedStatement.setObject(i + 1, args[i]);
			
		return preparedStatement;
	}
	
	private BeanManager beanManager;
}
